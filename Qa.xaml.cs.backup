using SkiaSharp.Views.Maui;
using SkiaSharp;
using System.Diagnostics;
using System.IO.Compression;
using System.Text;
using System.Text.RegularExpressions;
using System.Web;
using System.Linq;
using System.Collections.Generic;
using System.Text.Json;
using Microsoft.Maui.Controls;

namespace AnkiPlus_MAUI
{
    public partial class Qa : ContentPage
    {
        private string cardsFilePath;
        private string tempExtractPath;
        private List<CardData> cards = new List<CardData>();
        private List<CardData> sortedCards = new List<CardData>();
        private int currentIndex = 0;
        private int correctCount = 0;
        private int incorrectCount = 0;
        private System.Timers.Timer reviewTimer;
        private Services.LearningResultSyncService _learningResultSyncService;
        // クラスの先頭で変数を宣言
        private string selectedImagePath = "";
        private List<SKRect> selectionRects = new List<SKRect>();
        // 各問題ごとの正解・不正解回数を管理
        private Dictionary<int, CardResult> results = new Dictionary<int, CardResult>();
        private Dictionary<string, LearningRecord> learningRecords = new Dictionary<string, LearningRecord>();
        private bool showAnswer = false;  // 解答表示フラグ
        private string frontText = "";

        // ダークモード判定プロパティ
        private bool IsDarkMode => Application.Current?.RequestedTheme == AppTheme.Dark;

        // ダークモード対応色設定
        private struct ThemeColors
        {
            public static Color BackgroundColor => Application.Current?.RequestedTheme == AppTheme.Dark 
                ? Color.FromArgb("#1F1F1F") : Color.FromArgb("#FFFFFF");
            public static Color TextColor => Application.Current?.RequestedTheme == AppTheme.Dark 
                ? Color.FromArgb("#FFFFFF") : Color.FromArgb("#000000");
            public static Color BorderColor => Application.Current?.RequestedTheme == AppTheme.Dark 
                ? Color.FromArgb("#404040") : Color.FromArgb("#E0E0E0");
            public static Color CanvasBackground => Application.Current?.RequestedTheme == AppTheme.Dark 
                ? Color.FromArgb("#2F2F2F") : Color.FromArgb("#F5F5F5");
            public static string HtmlBackgroundColor => Application.Current?.RequestedTheme == AppTheme.Dark 
                ? "#1F1F1F" : "#FFFFFF";
            public static string HtmlTextColor => Application.Current?.RequestedTheme == AppTheme.Dark 
                ? "#FFFFFF" : "#000000";
            public static string HtmlCodeBackground => Application.Current?.RequestedTheme == AppTheme.Dark 
                ? "#2F2F2F" : "#F5F5F5";
        }

        // WebViewの動的高さ調整用の定数
        private const int MIN_WEBVIEW_HEIGHT = 100;  // 最小高さ
        private const int MAX_WEBVIEW_HEIGHT = 800;  // 最大高さ
        private const int HEIGHT_PADDING = 20;       // 余白

        // 新形式用のカードデータクラス
        private class CardData
        {
            public string id { get; set; }
            public string type { get; set; }
            public string front { get; set; }
            public string back { get; set; }
            public string question { get; set; }
            public string explanation { get; set; }
            public List<ChoiceItem> choices { get; set; }
            public List<SelectionRect> selectionRects { get; set; }
            public string imageFileName { get; set; } // 画像穴埋めカード用の画像ファイル名
        }
        private class ChoiceItem
        {
            public string text { get; set; }
            public bool isCorrect { get; set; }
        }
        private class SelectionRect
        {
            public float x { get; set; }
            public float y { get; set; }
            public float width { get; set; }
            public float height { get; set; }
        }

        private class CardResult
        {
            public bool WasCorrect { get; set; }  // 直前の正誤のみを保持
            public DateTime? NextReviewTime { get; set; }
            public int OriginalQuestionNumber { get; set; }  // 元の問題番号を保持
        }

        // iOS版と同じ学習記録構造体
        private class LearningRecord
        {
            public string CardId { get; set; }
            public int CorrectCount { get; set; }
            public int IncorrectCount { get; set; }
            public DateTime NextReviewDate { get; set; }
            public bool? LastResult { get; set; }  // true: 正解, false: 不正解, null: 未学習

            public LearningRecord(string cardId)
            {
                CardId = cardId;
                CorrectCount = 0;
                IncorrectCount = 0;
                NextReviewDate = DateTime.Now;
                LastResult = null;
            }
        }

        public Qa(string cardsPath, string tempPath)
        {
            InitializeComponent();
            // 一時フォルダ
            tempExtractPath = tempPath;
            cardsFilePath = Path.Combine(tempExtractPath, "cards.txt");
            
            // 学習記録同期サービスを初期化
            var blobStorageService = new Services.BlobStorageService();
            _learningResultSyncService = new Services.LearningResultSyncService(blobStorageService);
            
            LoadCards();
            LoadAndSortCards();
            InitializeTheme();
            DisplayCard();
            
            // アプリ起動時の同期を実行
            _ = InitializeLearningResultSync();
        }

        public Qa(List<string> cardsList)
        {
            InitializeComponent();
            // 一時フォルダを作成（結果保存用）
            tempExtractPath = Path.Combine(Path.GetTempPath(), "AnkiPlus_" + Guid.NewGuid().ToString());
            Directory.CreateDirectory(tempExtractPath);

            // 新形式ではこのコンストラクタは使わない想定ですが、空リストで初期化
            cards = new List<CardData>();
            LoadAndSortCards();
            Debug.WriteLine($"Loaded {cards.Count} cards");
            InitializeTheme();
            DisplayCard();
        }

        private void InitializeTheme()
        {
            // ページのバックグラウンドカラーを設定
            this.BackgroundColor = ThemeColors.BackgroundColor;
            
            // テーマ変更イベントの監視
            Application.Current.RequestedThemeChanged += OnRequestedThemeChanged;
        }

        private void OnRequestedThemeChanged(object sender, AppThemeChangedEventArgs e)
        {
            // テーマが変更された時の処理
            this.BackgroundColor = ThemeColors.BackgroundColor;
            
            // 現在表示中のカードを再描画
            MainThread.BeginInvokeOnMainThread(() =>
            {
                DisplayCard();
                CanvasView?.InvalidateSurface();
            });
        }

        protected override void OnAppearing()
        {
            base.OnAppearing();
            CanvasView.InvalidateSurface();
            LoadResultsFromFile();
            StartReviewTimer();
        }

        protected override void OnDisappearing()
        {
            base.OnDisappearing();
            // イベントの解除
            if (Application.Current != null)
            {
                Application.Current.RequestedThemeChanged -= OnRequestedThemeChanged;
            }
            StopReviewTimer();
            
            // 学習セッション終了時の同期
            _ = FinalizeLearningResultSync();
        }

        private async Task InitializeLearningResultSync()
        {
            try
            {
                if (App.CurrentUser != null && _learningResultSyncService != null)
                {
                    // ノート名を取得（tempExtractPathから抽出）
                    var noteName = GetNoteNameFromTempPath();
                    if (!string.IsNullOrEmpty(noteName))
                    {
                        await _learningResultSyncService.SyncOnAppStartAsync(App.CurrentUser.Uid, noteName);
                        Debug.WriteLine($"学習記録同期を初期化: {noteName}");
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"学習記録同期の初期化エラー: {ex.Message}");
            }
        }

        private async Task FinalizeLearningResultSync()
        {
            try
            {
                if (App.CurrentUser != null && _learningResultSyncService != null)
                {
                    var noteName = GetNoteNameFromTempPath();
                    if (!string.IsNullOrEmpty(noteName))
                    {
                        await _learningResultSyncService.SyncOnSessionEndAsync(App.CurrentUser.Uid, noteName);
                        Debug.WriteLine($"学習セッション終了時の同期完了: {noteName}");
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"学習セッション終了時の同期エラー: {ex.Message}");
            }
        }

        private string GetNoteNameFromTempPath()
        {
            try
            {
                // tempExtractPathから ノート名_temp の部分を抽出
                var dirName = Path.GetFileName(tempExtractPath);
                if (dirName.EndsWith("_temp"))
                {
                    return dirName.Substring(0, dirName.Length - 5); // "_temp"を除去
                }
                return null;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"ノート名の抽出エラー: {ex.Message}");
                return null;
            }
        }

        private void UpdateSyncFlag()
        {
            try
            {
                _learningResultSyncService?.OnQuestionAnswered();
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"同期フラグ更新エラー: {ex.Message}");
            }
        }

        // カードを読み込む
        private void LoadCards()
        {
            cards.Clear();
            string cardsDir = Path.Combine(tempExtractPath, "cards");
            if (!File.Exists(cardsFilePath) || !Directory.Exists(cardsDir)) return;

            var lines = File.ReadAllLines(cardsFilePath);
            foreach (var line in lines.Skip(1)) // 1行目はカード数
                        {
                if (string.IsNullOrWhiteSpace(line)) continue;
                var parts = line.Split(',');
                if (parts.Length < 1) continue;
                string uuid = parts[0];
                string jsonPath = Path.Combine(cardsDir, $"{uuid}.json");
                if (File.Exists(jsonPath))
                {
                    var json = File.ReadAllText(jsonPath);
                    var card = JsonSerializer.Deserialize<CardData>(json);
                    if (card != null) cards.Add(card);
                }
            }
            
            Debug.WriteLine($"Loaded {cards.Count} cards");
        }
        // 結果ファイルを読み込む
        private void LoadResultsFromFile()
        {
            try
            {
                string resultFilePath = Path.Combine(tempExtractPath, "result.txt");

                if (File.Exists(resultFilePath))
                {
                    var lines = File.ReadAllLines(resultFilePath);

                    foreach (var line in lines)
                    {
                        if (string.IsNullOrWhiteSpace(line)) continue;
                        
                        var parts = line.Split('|');
                        if (parts.Length >= 3)
                        {
                            // UUIDから対応するカードを検索
                            if (Guid.TryParse(parts[0].Trim(), out Guid cardGuid))
                            {
                                string cardId = cardGuid.ToString();
                                // カードのIDと一致するものを探す
                                var matchingCard = cards.FirstOrDefault(c => c.id == cardId);
                                if (matchingCard != null)
                                {
                                    int cardIndex = cards.IndexOf(matchingCard);
                                    int questionNumber = cardIndex + 1;

                                    if (!results.ContainsKey(questionNumber))
                                    {
                                        results[questionNumber] = new CardResult { OriginalQuestionNumber = questionNumber };
                                    }

                                    // 正解・不正解の解析
                                    var resultInfo = parts[1].Trim();
                                    results[questionNumber].WasCorrect = resultInfo == "正解";

                                    // 次回表示時間の解析
                                    if (DateTime.TryParse(parts[2].Trim(), out DateTime nextReview))
                                    {
                                        results[questionNumber].NextReviewTime = nextReview;
                                    }

                                    Debug.WriteLine($"カード {cardId} (問題 {questionNumber}) の結果を読み込み: {(results[questionNumber].WasCorrect ? "正解" : "不正解")}");
                                }
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"結果読み込み中にエラー: {ex.Message}");
            }
        }
        // 問題を表示
        private void DisplayCard()
        {
            try
            {
                Debug.WriteLine($"DisplayCard開始 - sortedCards.Count: {sortedCards?.Count ?? 0}, currentIndex: {currentIndex}");
                
                if (sortedCards == null || !sortedCards.Any())
                {
                    Debug.WriteLine("No cards available");
                    return;
                }

                if (currentIndex >= sortedCards.Count)
                {
                    Debug.WriteLine("すべての問題が出題されました");
                    // 復習が必要なカードがあるかチェック
                    ShowReviewNeededCards();
                    return;
                }

                var card = sortedCards[currentIndex];
                Debug.WriteLine($"Current card id: {card.id}, type: {card.type}");

                // レイアウトの初期化
                BasicCardLayout.IsVisible = false;
                ChoiceCardLayout.IsVisible = false;
                ImageFillCardLayout.IsVisible = false;

                if (card.type.Contains("基本"))
                {
                    Debug.WriteLine("Displaying basic card");
                    DisplayBasicCard(card);
                }
                else if (card.type.Contains("選択肢"))
                {
                    Debug.WriteLine("Displaying choice card");
                    DisplayChoiceCard(card);
                }
                else if (card.type.Contains("画像穴埋め"))
                {
                    Debug.WriteLine("Displaying image fill card");
                    DisplayImageFillCard(card);
                }
                else
                {
                    Debug.WriteLine($"Unknown card type: {card.type}");
                    // 不明なカードタイプの場合は次のカードへ
                    currentIndex++;
                    DisplayCard();
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error in DisplayCard: {ex}");
                DisplayAlert("Error", "Failed to display card", "OK");
            }
        }
        // 基本カードを解析
        private (string FrontText, string BackText) ParseBasicCard(List<string> lines)
        {
            var frontText = new StringBuilder();
            var backText = new StringBuilder();
            bool isFront = false;
            bool isBack = false;

            foreach (var line in lines)
            {
                if (line.StartsWith("表面:"))
                {
                    isFront = true;
                    isBack = false;
                    frontText.AppendLine(line.Substring(3));
                }
                else if (line.StartsWith("裏面:"))
                {
                    isBack = true;
                    isFront = false;
                    backText.AppendLine(line.Substring(3));
                }
                else
                {
                    if (isFront)
                    {
                        frontText.AppendLine(line);
                    }
                    else if (isBack)
                    {
                        backText.AppendLine(line);
                    }
                }
            }

            return (frontText.ToString().Trim(), backText.ToString().Trim());
        }
        // 基本・穴埋めカード表示
        private void DisplayBasicCard(CardData card)
        {
            BasicCardLayout.IsVisible = true;
            this.frontText = card.front ?? "";
            string frontText = card.front ?? "";
            string backText = card.back ?? "";

            // RichTextLabelにテキストを設定
            FrontPreviewLabel.RichText = frontText;
            FrontPreviewLabel.ShowAnswer = false;
            FrontPreviewLabel.ImageFolderPath = tempExtractPath;

            // 裏面が空でない場合のみ設定
            if (!string.IsNullOrWhiteSpace(backText))
            {
                BackPreviewLabel.RichText = backText;
                BackPreviewLabel.ShowAnswer = false;
                BackPreviewLabel.ImageFolderPath = tempExtractPath;
            }

            BackPreviewFrame.IsVisible = false;
        }
        // 選択肢カード表示
        private List<CheckBox> checkBoxes = new List<CheckBox>();  // チェックボックスを保持
        private List<bool> currentCorrectFlags = new List<bool>();  // 現在のカードの正誤情報

        private void DisplayChoiceCard(CardData card)
        {
            ChoiceCardLayout.IsVisible = true;

            var (question, explanation, choices, isCorrectFlags) = ParseChoiceCard(card);

            // 選択肢カードの問題Label設定
            ChoiceQuestionLabel.RichText = question;
            ChoiceQuestionLabel.ShowAnswer = false;
            ChoiceQuestionLabel.ImageFolderPath = tempExtractPath;

            ChoiceContainer.Children.Clear();
            checkBoxes.Clear();

            // 選択肢をシャッフル
            var random = new Random();
            var shuffledIndices = Enumerable.Range(0, choices.Count).OrderBy(x => random.Next()).ToList();
            var shuffledChoices = shuffledIndices.Select(i => choices[i]).ToList();
            currentCorrectFlags = shuffledIndices.Select(i => isCorrectFlags[i]).ToList();  // シャッフルされた正誤フラグを保存

            for (int i = 0; i < shuffledChoices.Count; i++)
            {
                var choiceText = shuffledChoices[i];

                var choiceLayout = new HorizontalStackLayout
                {
                    Spacing = 10
                };

                // チェックボックス
                var checkBox = new CheckBox
                {
                    IsChecked = false
                };

                checkBoxes.Add(checkBox);

                // 選択肢のラベル（クリック可能なボタンとして実装）
                var choiceButton = new Button
                {
                    Text = choiceText,
                    VerticalOptions = LayoutOptions.Center,
                    BackgroundColor = Colors.Transparent,
                    TextColor = ThemeColors.TextColor,
                    FontSize = 16,
                    Padding = new Thickness(0),
                    Margin = new Thickness(0)
                };

                // ボタンのクリックイベント
                int index = i; // クロージャのためにインデックスを保存
                choiceButton.Clicked += (s, e) =>
                {
                    checkBox.IsChecked = !checkBox.IsChecked;
                };

                // 正誤マークを表示するための Label
                var resultLabel = new Label
                {
                    Text = "",
                    VerticalOptions = LayoutOptions.Center,
                    TextColor = ThemeColors.TextColor,
                    IsVisible = false
                };

                // チェックボックスとボタンを追加
                choiceLayout.Children.Add(checkBox);
                choiceLayout.Children.Add(choiceButton);
                choiceLayout.Children.Add(resultLabel);

                ChoiceContainer.Children.Add(choiceLayout);
            }

            // 解説が空でない場合のみ設定
            if (!string.IsNullOrWhiteSpace(explanation))
            {
                ChoiceExplanationLabel.RichText = explanation;
                ChoiceExplanationLabel.ShowAnswer = false;
                ChoiceExplanationLabel.ImageFolderPath = tempExtractPath;
            }
            ChoiceExplanationFrame.IsVisible = false;
        }

        private async void DisplayImageFillCard(CardData card)
        {
            ImageFillCardLayout.IsVisible = true;
            selectionRects.Clear();

            // imageFileNameフィールドから画像ファイル名を取得
            string imageFileName = GetImageFileNameFromCard(card);

            if (!string.IsNullOrWhiteSpace(imageFileName))
            {
                // フルパスを作成
                string imageFolder = Path.Combine(tempExtractPath, "img");
                selectedImagePath = Path.Combine(imageFolder, imageFileName);

                if (File.Exists(selectedImagePath))
                {
                    Debug.WriteLine($"画像読み込み成功: {selectedImagePath}");
                    CanvasView.InvalidateSurface();  // 再描画
                }
                else
                {
                    Debug.WriteLine($"画像が存在しません: {selectedImagePath}");
                    Debug.WriteLine($"探索パス: {selectedImagePath}");
                    Debug.WriteLine($"imgフォルダ内容: {string.Join(", ", Directory.GetFiles(imageFolder))}");
                    await DisplayAlert("エラー", "画像が存在しません。", "OK");
                    return;
                }
            }
            else
            {
                Debug.WriteLine($"画像ファイル名が取得できません。card.front: '{card.front}', JSONデータ確認が必要");
                await DisplayAlert("エラー", "画像パスが無効です。", "OK");
                return;
            }

            // 範囲の追加
            foreach (var line in card.selectionRects)
                {
                selectionRects.Add(new SKRect(line.x, line.y, line.x + line.width, line.y + line.height));
            }

            CanvasView.InvalidateSurface();
        }

        /// <summary>
        /// カードデータから画像ファイル名を取得
        /// </summary>
        private string GetImageFileNameFromCard(CardData card)
        {
            // 新形式: imageFileNameフィールドから取得
            if (!string.IsNullOrWhiteSpace(card.imageFileName))
            {
                Debug.WriteLine($"新形式の画像ファイル名を使用: {card.imageFileName}");
                return card.imageFileName;
            }

            // 旧形式: frontフィールドから取得（後方互換性のため）
            if (!string.IsNullOrWhiteSpace(card.front))
            {
                Debug.WriteLine($"旧形式のfrontフィールドを使用: {card.front}");
                return card.front;
            }

            Debug.WriteLine("画像ファイル名が見つかりません");
            return null;
        }

        private void OnCanvasViewPaintSurface(object sender, SKPaintSurfaceEventArgs e)
        {
            var surface = e.Surface;
            var canvas = surface.Canvas;
            var info = e.Info;

            // ダークモード対応の背景色
            var backgroundColor = IsDarkMode ? SKColors.Black : SKColors.White;
            canvas.Clear(backgroundColor);

            if (string.IsNullOrWhiteSpace(selectedImagePath) || !File.Exists(selectedImagePath))
            {
                Debug.WriteLine("画像が選択されていないか、存在しません。");
                return;
            }

            try
            {
                // ファイルパスから直接画像を読み込む
                using (var stream = File.OpenRead(selectedImagePath))
                {
                    var bitmap = SKBitmap.Decode(stream);
                    Debug.WriteLine($"画像サイズ: {bitmap.Width} x {bitmap.Height}");
                    Debug.WriteLine($"キャンバスサイズ: {info.Width} x {info.Height}");
                    
                    if (bitmap == null)
                    {
                        Debug.WriteLine("画像のデコードに失敗しました。");
                        return;
                    }

                    // アスペクト比を維持して画像を描画
                    float imageAspect = (float)bitmap.Width / bitmap.Height;
                    float canvasAspect = (float)info.Width / info.Height;
                    
                    SKRect imageRect;
                    float scale;
                    
                    if (imageAspect > canvasAspect)
                    {
                        // 画像の方が横長：幅をキャンバスに合わせ、高さを調整
                        scale = (float)info.Width / bitmap.Width;
                        float scaledHeight = bitmap.Height * scale;
                        float offsetY = (info.Height - scaledHeight) / 2;
                        imageRect = new SKRect(0, offsetY, info.Width, offsetY + scaledHeight);
                    }
                    else
                    {
                        // 画像の方が縦長：高さをキャンバスに合わせ、幅を調整
                        scale = (float)info.Height / bitmap.Height;
                        float scaledWidth = bitmap.Width * scale;
                        float offsetX = (info.Width - scaledWidth) / 2;
                        imageRect = new SKRect(offsetX, 0, offsetX + scaledWidth, info.Height);
                    }
                    
                    canvas.DrawBitmap(bitmap, imageRect);
                    Debug.WriteLine($"描画領域: {imageRect.Left}, {imageRect.Top}, {imageRect.Right}, {imageRect.Bottom}");
                    Debug.WriteLine($"スケール: {scale}");

                    // 正規化座標を実際の座標に変換して範囲を表示
                    foreach (var normalizedRect in selectionRects)
                    {
                        // 正規化座標を実際の画像座標に変換
                        float actualX = normalizedRect.Left * bitmap.Width;
                        float actualY = normalizedRect.Top * bitmap.Height;
                        float actualWidth = normalizedRect.Width * bitmap.Width;
                        float actualHeight = normalizedRect.Height * bitmap.Height;
                        
                        // 画像座標をキャンバス座標に変換
                        float canvasX = imageRect.Left + (actualX * scale);
                        float canvasY = imageRect.Top + (actualY * scale);
                        float canvasWidth = actualWidth * scale;
                        float canvasHeight = actualHeight * scale;
                        
                        var displayRect = new SKRect(canvasX, canvasY, canvasX + canvasWidth, canvasY + canvasHeight);
                        
                        // ダークモード対応の色設定
                        var fillColor = IsDarkMode ? SKColors.DarkRed : SKColors.Red;
                        var borderColor = IsDarkMode ? SKColors.White : SKColors.Black;
                        
                        // 塗りつぶし用のペイント
                        using (var fillPaint = new SKPaint
                        {
                            Color = fillColor,
                            Style = SKPaintStyle.Fill
                        })
                        {
                            canvas.DrawRect(displayRect, fillPaint);
                        }

                        // 枠線表示
                        using (var borderPaint = new SKPaint
                        {
                            Color = borderColor,
                            Style = SKPaintStyle.Stroke,
                            StrokeWidth = 3
                        })
                        {
                            canvas.DrawRect(displayRect, borderPaint);
                        }

                        Debug.WriteLine($"正規化座標: {normalizedRect.Left:F3}, {normalizedRect.Top:F3}, {normalizedRect.Width:F3}, {normalizedRect.Height:F3}");
                        Debug.WriteLine($"表示座標: {displayRect.Left:F1}, {displayRect.Top:F1}, {displayRect.Right:F1}, {displayRect.Bottom:F1}");
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"描画中にエラーが発生しました: {ex.Message}");
            }
        }

        // 選択肢カードを解析
        private (string Question, string Explanation, List<string> Choices, List<bool> IsCorrect) ParseChoiceCard(CardData card)
        {
            string question = card.question ?? "";
            string explanation = card.explanation ?? "";
            var choices = new List<string>();
            var isCorrectFlags = new List<bool>();
            if (card.choices != null)
            {
                foreach (var c in card.choices)
                {
                    choices.Add(c.text);
                    isCorrectFlags.Add(c.isCorrect);
                }
            }
            return (question, explanation, choices, isCorrectFlags);
        }

        private async void OnShowAnswerClicked(object sender, EventArgs e)
        {
            if (BasicCardLayout.IsVisible)
            {
                showAnswer = true;  // 解答表示フラグを有効に
                
                // RichTextLabelで解答を表示
                FrontPreviewLabel.ShowAnswer = true;
                
                // 裏面が空でない場合のみ表示
                var currentCard = sortedCards[currentIndex];
                if (!string.IsNullOrWhiteSpace(currentCard.back))
                {
                    BackPreviewFrame.IsVisible = true;
                    BackPreviewLabel.ShowAnswer = true;
                }
                else
                {
                    BackPreviewFrame.IsVisible = false;
                }
                Correct.IsVisible = true;
                Incorrect.IsVisible = true;
                AnswerLine.IsVisible = true;
                SeparatorGrid.IsVisible = true;
                ShowAnswerButton.IsVisible = false;
            }
            else if (ChoiceCardLayout.IsVisible)
            {
                // 選択肢の正誤を判定
                bool isCorrect = true;
                for (int i = 0; i < checkBoxes.Count; i++)
                {
                    var checkBox = checkBoxes[i];
                    var parentLayout = (HorizontalStackLayout)checkBox.Parent;
                    var resultLabel = (Label)parentLayout.Children[2];

                    if (checkBox.IsChecked != currentCorrectFlags[i])
                    {
                        isCorrect = false;
                    }

                    if (currentCorrectFlags[i])
                    {
                        resultLabel.Text = "正";
                        resultLabel.TextColor = IsDarkMode ? Color.FromArgb("#90EE90") : Colors.Green;
                        resultLabel.IsVisible = true;
                    }
                    else
                    {
                        resultLabel.Text = "誤";
                        resultLabel.TextColor = IsDarkMode ? Color.FromArgb("#FF6B6B") : Colors.Red;
                        resultLabel.IsVisible = true;
                    }
                }

                // 結果を保存
                if (!results.ContainsKey(currentIndex + 1))
                {
                    results[currentIndex + 1] = new CardResult();
                }

                var result = results[currentIndex + 1];
                result.WasCorrect = isCorrect;

                // 次回表示時間を設定
                if (isCorrect)
                {
                    // 2回目以降の正解：1日後、初回正解：10分後
                    result.NextReviewTime = result.WasCorrect ? DateTime.Now.AddDays(1) : DateTime.Now.AddMinutes(10);
                }
                else
                {
                    // 不正解：連続不正解なら1分後、前回正解なら10分後
                    result.NextReviewTime = DateTime.Now.AddMinutes(result.WasCorrect ? 10 : 1);
                }

                                // iOS版と同じ形式でresult.txtに保存
                var currentCard = sortedCards[currentIndex];
                SaveLearningRecord(currentCard, isCorrect);

                // 学習記録同期フラグを更新
                UpdateSyncFlag();

                // 解説が空でない場合のみ表示
                var currentCards = sortedCards[currentIndex];
                if (!string.IsNullOrWhiteSpace(currentCards.explanation))
                {
                    ChoiceExplanationFrame.IsVisible = true;
                }
                else
                {
                    ChoiceExplanationFrame.IsVisible = false;
                }

                // 「次へ」ボタンを表示
                ShowAnswerButton.IsVisible = false;
                NextButton.IsVisible = true;
            }
            else if (ImageFillCardLayout.IsVisible)
            {
                selectionRects.Clear();
                CanvasView.InvalidateSurface();
                Correct.IsVisible = true;
                Incorrect.IsVisible = true;
                AnswerLine.IsVisible = true;
                SeparatorGrid.IsVisible = true;
                ShowAnswerButton.IsVisible = false;

                // 画像穴埋め問題の結果を保存（正解・不正解ボタンで判定されるため、ここでは初期化のみ）
                if (!results.ContainsKey(currentIndex + 1))
                {
                    results[currentIndex + 1] = new CardResult();
                }
            }
        }

        private void OnNextClicked(object sender, EventArgs e)
        {
            try
            {
                currentIndex++;
                ShowAnswerButton.IsVisible = true;
                NextButton.IsVisible = false;
                Debug.WriteLine($"次の問題へ移動: {currentIndex + 1}/{cards.Count}");
                DisplayCard();
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error in OnNextClicked: {ex}");
                DisplayAlert("Error", "Failed to move to next card", "OK");
            }
        }

        // 正解ボタン
        private void OnCorrectClicked(object sender, EventArgs e)
        {
            try
            {
                var currentCard = sortedCards[currentIndex];
                
                // 現在のカードのインデックスをそのまま利用
                int questionNumber = currentIndex + 1;
                    if (!results.ContainsKey(questionNumber))
                    {
                        results[questionNumber] = new CardResult { OriginalQuestionNumber = questionNumber };
                    }
                    var result = results[questionNumber];
                    result.WasCorrect = true;  // 正解として記録
                    result.OriginalQuestionNumber = questionNumber;  // 元の問題番号を保持
                
                    // 次回表示時間を設定
                if (result.WasCorrect)
                {
                    // 2回目以降の正解：1日後
                    result.NextReviewTime = DateTime.Now.AddDays(1);
                }
                else
                {
                    // 初回正解：10分後
                    result.NextReviewTime = DateTime.Now.AddMinutes(10);
                }
                
                // iOS版と同じ形式でresult.txtに保存
                SaveLearningRecord(currentCard, true);

                // 学習記録同期フラグを更新
                UpdateSyncFlag();

                currentIndex++;
                Correct.IsVisible = false;
                Incorrect.IsVisible = false;
                AnswerLine.IsVisible = false;
                SeparatorGrid.IsVisible = false;
                ShowAnswerButton.IsVisible = true;
                DisplayCard();
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error in OnCorrectClicked: {ex}");
                DisplayAlert("Error", "Failed to process correct answer", "OK");
            }
        }

        // 不正解ボタン
        private void OnIncorrectClicked(object sender, EventArgs e)
        {
            try
            {
                var currentCard = sortedCards[currentIndex];
                
                int questionNumber = currentIndex + 1;
                    if (!results.ContainsKey(questionNumber))
                    {
                        results[questionNumber] = new CardResult { OriginalQuestionNumber = questionNumber };
                    }
                    var result = results[questionNumber];
                    result.WasCorrect = false;  // 不正解として記録
                    result.OriginalQuestionNumber = questionNumber;  // 元の問題番号を保持
                
                    // 次回表示時間を設定
                if (result.WasCorrect)
                {
                    // 前回が正解で今回不正解：10分後
                    result.NextReviewTime = DateTime.Now.AddMinutes(10);
                }
                else
                {
                    // 連続不正解：1分後
                    result.NextReviewTime = DateTime.Now.AddMinutes(1);
                }
                
                // iOS版と同じ形式でresult.txtに保存
                SaveLearningRecord(currentCard, false);

                // 学習記録同期フラグを更新
                UpdateSyncFlag();

                currentIndex++;
                Correct.IsVisible = false;
                Incorrect.IsVisible = false;
                AnswerLine.IsVisible = false;
                SeparatorGrid.IsVisible = false;
                ShowAnswerButton.IsVisible = true;
                DisplayCard();
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Error in OnIncorrectClicked: {ex}");
                DisplayAlert("Error", "Failed to process incorrect answer", "OK");
            }
        }

        string ConvertImageToBase64(string imagePath)
        {
            if (!File.Exists(imagePath))
            {
                return null;
            }

            byte[] imageBytes = File.ReadAllBytes(imagePath);
            string base64String = Convert.ToBase64String(imageBytes);
            string mimeType = Path.GetExtension(imagePath).ToLower() switch
            {
                ".png" => "image/png",
                ".jpg" => "image/jpeg",
                ".jpeg" => "image/jpeg",
                ".gif" => "image/gif",
                _ => "application/octet-stream"
            };

            return $"data:{mimeType};base64,{base64String}";
        }

        // 枠組みのHTMLテンプレートを生成
        private string CreateBaseHtmlTemplate()
        {
            var redColor = IsDarkMode ? "#FF6B6B" : "red";
            
            return $@"
            <html>
            <head>
                <meta name='viewport' content='width=device-width, initial-scale=1.0'>
                <style>
                    body {{ 
                        font-size: 18px; 
                        font-family: Arial, sans-serif; 
                        line-height: 1.5; 
                        white-space: pre-line;
                        background-color: {ThemeColors.HtmlBackgroundColor};
                        color: {ThemeColors.HtmlTextColor};
                        margin: 10px;
                        padding: 10px;
                        min-height: 100vh;
                    }}
                    sup {{ vertical-align: super; font-size: smaller; }}
                    sub {{ vertical-align: sub; font-size: smaller; }}
                    img {{ 
                        display: block; 
                        margin: 10px 0; 
                        border-radius: 8px;
                        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                    }}
                    code {{
                        background-color: {ThemeColors.HtmlCodeBackground};
                        padding: 2px 4px;
                        border-radius: 4px;
                        font-family: 'Courier New', monospace;
                    }}
                    pre {{
                        background-color: {ThemeColors.HtmlCodeBackground};
                        padding: 10px;
                        border-radius: 8px;
                        overflow-x: auto;
                    }}
                    .blank-placeholder {{
                        min-width: 20px;
                        display: inline-block;
                    }}
                    #main-content {{
                        opacity: 1;
                        transition: opacity 0.3s ease;
                    }}
                    .loading {{
                        opacity: 0.5;
                    }}
                </style>
                <script>
                    function updateContent(content) {{
                        var mainContent = document.getElementById('main-content');
                        if (mainContent) {{
                            mainContent.innerHTML = content;
                            // コンテンツ更新後に高さを調整
                            setTimeout(function() {{
                                adjustHeight();
                            }}, 100);
                        }}
                    }}
                    
                    function showAllAnswers() {{
                        var blanks = document.querySelectorAll('.blank-placeholder');
                        blanks.forEach(function(blank) {{
                            var answer = blank.getAttribute('data-answer');
                            if (answer) {{
                                blank.textContent = answer;
                                blank.style.color = '{redColor}';
                            }}
                        }});
                        // 解答表示後に高さを調整
                        setTimeout(function() {{
                            adjustHeight();
                        }}, 100);
                    }}
                    
                    function showAnswer(blankId, answer) {{
                        var element = document.getElementById(blankId);
                        if (element) {{
                            element.textContent = answer;
                            element.style.color = '{redColor}';
                        }}
                        // 特定の解答表示後に高さを調整
                        setTimeout(function() {{
                            adjustHeight();
                        }}, 100);
                    }}
                    
                    function insertText(elementId, text) {{
                        var element = document.getElementById(elementId);
                        if (element) {{
                            element.innerHTML = text;
                        }}
                        // テキスト挿入後に高さを調整
                        setTimeout(function() {{
                            adjustHeight();
                        }}, 100);
                    }}
                    
                    function setLoading(isLoading) {{
                        var mainContent = document.getElementById('main-content');
                        if (isLoading) {{
                            mainContent.classList.add('loading');
                        }} else {{
                            mainContent.classList.remove('loading');
                        }}
                    }}
                    
                    function adjustHeight() {{
                        try {{
                            var mainContent = document.getElementById('main-content');
                            if (mainContent) {{
                                var contentHeight = mainContent.scrollHeight;
                                var bodyHeight = document.body.scrollHeight;
                                var totalHeight = Math.max(contentHeight, bodyHeight);
                                
                                // C#側に高さを通知
                                if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.heightHandler) {{
                                    // iOS
                                    window.webkit.messageHandlers.heightHandler.postMessage(totalHeight);
                                }} else if (window.AndroidInterface) {{
                                    // Android
                                    window.AndroidInterface.adjustHeight(totalHeight);
                                }} else {{
                                    // フォールバック：URLスキームを使用
                                    window.location.href = 'height://' + totalHeight;
                                }}
                            }}
                        }} catch (e) {{
                            console.log('高さ調整エラー:', e);
                        }}
                    }}
                    
                    // ページ読み込み完了時に高さを調整
                    window.addEventListener('load', function() {{
                        setTimeout(function() {{
                            adjustHeight();
                        }}, 200);
                    }});
                    
                    // 画像読み込み完了時にも高さを調整
                    document.addEventListener('DOMContentLoaded', function() {{
                        var images = document.querySelectorAll('img');
                        images.forEach(function(img) {{
                            img.addEventListener('load', function() {{
                                setTimeout(function() {{
                                    adjustHeight();
                                }}, 100);
                            }});
                        }});
                    }});
                </script>
            </head>
            <body>
                <div id='main-content'>読み込み中...</div>
            </body>
            </html>";
        }

        // コンテンツ部分のみのHTMLを生成
        private string ConvertToContentHtml(string text, bool showAnswer = false)
        {
            if (string.IsNullOrWhiteSpace(text)) return "";

            // 画像タグを最初に処理
            var matches = Regex.Matches(text, @"<<img_.*?\.jpg>>");
            Debug.WriteLine($"画像タグ数: {matches.Count}");
            foreach (Match match in matches)
            {
                string imgFileName = match.Value.Trim('<', '>');
                string imgPath = Path.Combine(tempExtractPath, "img", imgFileName);

                if (File.Exists(imgPath))
                {
                    string base64Image = ConvertImageToBase64(imgPath);
                    if (base64Image != null)
                    {
                        text = text.Replace(match.Value, $"<img src={base64Image} style=max-height:150px; />");
                    }
                    else
                    {
                        text = text.Replace(match.Value, $"[画像が見つかりません: {imgFileName}]");
                    }
                }
                else
                {
                    text = text.Replace(match.Value, $"[画像が見つかりません: {imgFileName}]");
                }
            }

            // 穴埋め表示処理（JavaScript操作用のIDを付与）
            int blankCounter = 0;
            if (showAnswer)
            {
                Debug.WriteLine(frontText);
                // 解答表示時は `<<blank|文字>>` → `(文字)`
                text = Regex.Replace(text, @"<<blank\|(.*?)>>", match =>
                {
                    blankCounter++;
                    var answer = match.Groups[1].Value;
                    return $"(<span id='blank_{blankCounter}' style='color:{(IsDarkMode ? "#FF6B6B" : "red")};'>{answer}</span>)";
                });
            }
            else
            {
                // 問題表示時は `<<blank|文字>>` → `( )` （後でJavaScriptで操作可能）
                text = Regex.Replace(text, @"<<blank\|(.*?)>>", match =>
                {
                    blankCounter++;
                    var answer = match.Groups[1].Value;
                    return $"(<span id='blank_{blankCounter}' data-answer='{HttpUtility.HtmlEncode(answer)}' class='blank-placeholder'> </span>)";
                });
            }

            // 穴埋めのspanタグを一時的に保護
            var protectedSpans = new List<string>();
            int spanIndex = 0;
            text = Regex.Replace(text, @"<span[^>]*>.*?</span>", match =>
            {
                var placeholder = $"__SPAN_PLACEHOLDER_{spanIndex}__";
                protectedSpans.Add(match.Value);
                spanIndex++;
                return placeholder;
            });

            // HTML エスケープ
            text = HttpUtility.HtmlEncode(text);

            // 保護されたspanタグを復元
            for (int i = 0; i < protectedSpans.Count; i++)
            {
                text = text.Replace($"__SPAN_PLACEHOLDER_{i}__", protectedSpans[i]);
            }

            // 太字変換
            text = Regex.Replace(text, @"\*\*(.*?)\*\*", "<b>$1</b>");

            // ダークモード対応の色変換
            var redColor = IsDarkMode ? "#FF6B6B" : "red";
            var blueColor = IsDarkMode ? "#6BB6FF" : "blue";
            var greenColor = IsDarkMode ? "#90EE90" : "green";
            var yellowColor = IsDarkMode ? "#FFD700" : "yellow";
            var purpleColor = IsDarkMode ? "#DA70D6" : "purple";
            var orangeColor = IsDarkMode ? "#FFA500" : "orange";
            
            text = Regex.Replace(text, @"\{\{red\|(.*?)\}\}", $"<span style='color:{redColor};'>$1</span>");
            text = Regex.Replace(text, @"\{\{blue\|(.*?)\}\}", $"<span style='color:{blueColor};'>$1</span>");
            text = Regex.Replace(text, @"\{\{green\|(.*?)\}\}", $"<span style='color:{greenColor};'>$1</span>");
            text = Regex.Replace(text, @"\{\{yellow\|(.*?)\}\}", $"<span style='color:{yellowColor};'>$1</span>");
            text = Regex.Replace(text, @"\{\{purple\|(.*?)\}\}", $"<span style='color:{purpleColor};'>$1</span>");
            text = Regex.Replace(text, @"\{\{orange\|(.*?)\}\}", $"<span style='color:{orangeColor};'>$1</span>");

            // 上付き・下付き変換
            text = Regex.Replace(text, @"\^\^(.*?)\^\^", "<sup>$1</sup>");
            text = Regex.Replace(text, @"~~(.*?)~~", "<sub>$1</sub>");

            // 必要な部分だけデコード処理
            text = Regex.Replace(text, @"&lt;img(.*?)&gt;", "<img$1>");

            // 改行を `<br>` に変換
            text = text.Replace(Environment.NewLine, "<br>").Replace("\n", "<br>");

            return text;
        }

        // 互換性のため残す（レガシー用）
        private string ConvertMarkdownToHtml(string text, bool showAnswer = false)
        {
            var content = ConvertToContentHtml(text, showAnswer);
            return CreateBaseHtmlTemplate().Replace("読み込み中...", content);
        }

        // WebViewで穴埋めの解答を表示するJavaScript実行
        private async Task ShowBlankAnswersWithJavaScript(WebView webView)
        {
            try
            {
                await webView.EvaluateJavaScriptAsync("showAllAnswers();");
                Debug.WriteLine("JavaScript: 穴埋め解答を表示");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"JavaScript実行エラー: {ex.Message}");
                // JavaScriptが失敗した場合、従来通りHTML全体を再生成
                Debug.WriteLine("JavaScript失敗 - HTML再生成でフォールバック");
                await FallbackToHtmlRegeneration(webView);
            }
        }

        // JavaScript失敗時のフォールバック：HTML全体再生成
        private async Task FallbackToHtmlRegeneration(WebView webView)
        {
            try
            {
                await MainThread.InvokeOnMainThreadAsync(() =>
                {
                    if (webView == FrontPreviewWebView)
                    {
                        var answerFrontHtml = ConvertMarkdownToHtml(frontText, showAnswer: true);
                        webView.Source = new HtmlWebViewSource
                        {
                            Html = answerFrontHtml
                        };
                        Debug.WriteLine("HTML再生成完了");
                    }
                });
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"HTML再生成でもエラー: {ex.Message}");
            }
        }

        // WebViewに特定のテキストを挿入
        private async Task InsertTextToWebView(WebView webView, string elementId, string text)
        {
            try
            {
                var escapedText = text.Replace("'", "\\'").Replace("\"", "\\\"");
                await webView.EvaluateJavaScriptAsync($"insertText('{elementId}', '{escapedText}');");
                Debug.WriteLine($"JavaScript: {elementId}にテキスト挿入");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"JavaScript実行エラー: {ex.Message}");
            }
        }

        // 特定の穴埋めだけを表示
        private async Task ShowSpecificBlank(WebView webView, int blankNumber, string answer)
        {
            try
            {
                var escapedAnswer = answer.Replace("'", "\\'").Replace("\"", "\\\"");
                await webView.EvaluateJavaScriptAsync($"showAnswer('blank_{blankNumber}', '{escapedAnswer}');");
                Debug.WriteLine($"JavaScript: blank_{blankNumber}に解答表示");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"JavaScript実行エラー: {ex.Message}");
            }
        }

        // WebViewのコンテンツに任意のJavaScriptを実行
        private async Task ExecuteJavaScript(WebView webView, string javascript)
        {
            try
            {
                var result = await webView.EvaluateJavaScriptAsync(javascript);
                Debug.WriteLine($"JavaScript実行結果: {result}");
                return;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"JavaScript実行エラー: {ex.Message}");
            }
        }

        // WebViewのコンテンツ部分のみを更新
        private async Task UpdateWebViewContent(WebView webView, string text, bool showAnswer)
        {
            try
            {
                var contentHtml = ConvertToContentHtml(text, showAnswer);
                var escapedContent = contentHtml.Replace("'", "\\'").Replace("\"", "\\\"").Replace("\n", "\\n").Replace("\r", "");
                
                await webView.EvaluateJavaScriptAsync($"updateContent('{escapedContent}');");
                Debug.WriteLine("WebViewコンテンツ更新完了");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"WebViewコンテンツ更新エラー: {ex.Message}");
                // フォールバック：HTML全体を再読み込み
                var fullHtml = ConvertMarkdownToHtml(text, showAnswer);
                webView.Source = new HtmlWebViewSource { Html = fullHtml };
            }
        }

        // WebViewの高さを動的に調整
        private void AdjustWebViewHeight(WebView webView, double contentHeight)
        {
            try
            {
                MainThread.BeginInvokeOnMainThread(() =>
                {
                    // コンテンツの高さに余白を追加
                    var adjustedHeight = Math.Max(MIN_WEBVIEW_HEIGHT, 
                                                 Math.Min(MAX_WEBVIEW_HEIGHT, 
                                                         contentHeight + HEIGHT_PADDING));
                    
                    webView.HeightRequest = adjustedHeight;
                    Debug.WriteLine($"WebView高さ調整: {contentHeight} → {adjustedHeight}");
                });
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"WebView高さ調整エラー: {ex.Message}");
            }
        }

        // WebViewのNavigatedイベントでURLスキームを処理
        private void OnWebViewNavigated(object sender, WebNavigatedEventArgs e)
        {
            try
            {
                if (e.Url.StartsWith("height://"))
                {
                    var heightStr = e.Url.Replace("height://", "");
                    if (double.TryParse(heightStr, out double height))
                    {
                        var webView = sender as WebView;
                        AdjustWebViewHeight(webView, height);
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"WebView Navigated処理エラー: {ex.Message}");
            }
        }

        // 学習記録を保存（iOS版と同じ形式）
        private void SaveLearningRecord(CardData card, bool isCorrect)
        {
            try
            {
                string resultFilePath = Path.Combine(tempExtractPath, "result.txt");

                // 結果の文字列
                string result = isCorrect ? "正解" : "不正解";

                // result.txtから既存の記録があるかを確認
                bool hasExistingRecord = CheckExistingRecord(card.id, resultFilePath);

                // 前回の結果を取得（既存記録がある場合）
                bool? previousResult = null;
                if (hasExistingRecord)
                {
                    previousResult = GetPreviousResult(card.id, resultFilePath);
                }

                // 次回復習時間の計算（iOS版と同じロジック）
                DateTime nextReviewDate;
                if (isCorrect)
                {
                    // 正解の場合
                    if (hasExistingRecord)
                    {
                        // 2回目以降の正解：1日後
                        nextReviewDate = DateTime.Now.AddDays(1);
                        Debug.WriteLine($"カード {card.id}: 2回目以降の正解 → 1日後に復習");
                    }
                    else
                    {
                        // 初回正解：10分後
                        nextReviewDate = DateTime.Now.AddMinutes(10);
                        Debug.WriteLine($"カード {card.id}: 初回正解 → 10分後に復習");
                    }
                }
                else
                {
                    // 不正解の場合
                    if (hasExistingRecord && previousResult == true)
                    {
                        // 前回が正解で今回不正解：10分後
                        nextReviewDate = DateTime.Now.AddMinutes(10);
                        Debug.WriteLine($"カード {card.id}: 前回正解→今回不正解 → 10分後に復習");
                    }
                    else
                    {
                        // 初回不正解または連続不正解：1分後
                        nextReviewDate = DateTime.Now.AddMinutes(1);
                        Debug.WriteLine($"カード {card.id}: 初回不正解または連続不正解 → 1分後に復習");
                    }
                }

                // 日時を文字列に変換（iOS版と同じ形式）
                string nextReviewDateStr = nextReviewDate.ToString("yyyy/MM/dd HH:mm:ss");

                // iOS版と同じ形式：{UUID}|{正解/不正解}|{次回復習時間}
                string recordLine = $"{card.id}|{result}|{nextReviewDateStr}";

                // ファイルに追記
                File.AppendAllText(resultFilePath, recordLine + Environment.NewLine);

                // メモリ内の学習記録も更新
                UpdateLearningRecord(card, isCorrect, nextReviewDate);

                Debug.WriteLine($"学習記録を保存: {recordLine}");
                Debug.WriteLine($"保存先: {resultFilePath}");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"学習記録保存エラー: {ex.Message}");
            }
        }

        // result.txtに既存の記録があるかチェック
        private bool CheckExistingRecord(string cardId, string resultFilePath)
        {
            try
            {
                if (!File.Exists(resultFilePath))
                {
                    Debug.WriteLine($"result.txtが存在しないため、カード {cardId} は初回");
                    return false;
                }

                var lines = File.ReadAllLines(resultFilePath);
                foreach (string line in lines)
                {
                    if (string.IsNullOrWhiteSpace(line)) continue;
                    
                    var parts = line.Split('|');
                    if (parts.Length >= 1 && parts[0].Trim().Equals(cardId, StringComparison.OrdinalIgnoreCase))
                    {
                        Debug.WriteLine($"カード {cardId} の既存記録を発見");
                        return true;
                    }
                }
                
                Debug.WriteLine($"カード {cardId} の既存記録なし（初回）");
                return false;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"既存記録チェック中にエラー: {ex.Message}");
                return false;
            }
        }

        // 前回の結果を取得
        private bool? GetPreviousResult(string cardId, string resultFilePath)
        {
            try
            {
                if (!File.Exists(resultFilePath)) return null;

                var lines = File.ReadAllLines(resultFilePath);
                // 最後の記録を取得（最新の結果）
                for (int i = lines.Length - 1; i >= 0; i--)
                {
                    string line = lines[i];
                    if (string.IsNullOrWhiteSpace(line)) continue;
                    
                    var parts = line.Split('|');
                    if (parts.Length >= 2 && parts[0].Trim().Equals(cardId, StringComparison.OrdinalIgnoreCase))
                    {
                        bool wasCorrect = parts[1].Trim() == "正解";
                        Debug.WriteLine($"カード {cardId} の前回結果: {(wasCorrect ? "正解" : "不正解")}");
                        return wasCorrect;
                    }
                }
                
                return null;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"前回結果取得中にエラー: {ex.Message}");
                return null;
            }
        }

        // 結果を即時保存（互換性のため残す）
        private void SaveResultsToFile()
        {
            try
            {
                if (currentIndex < sortedCards.Count)
                {
                    var currentCard = sortedCards[currentIndex];
                    if (results.ContainsKey(currentIndex + 1))
                    {
                        SaveLearningRecord(currentCard, results[currentIndex + 1].WasCorrect);
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"結果の保存中にエラーが発生: {ex.Message}");
            }
        }

        // iOS版と同じ学習記録の読み込みとカードソート
        private void LoadAndSortCards()
        {
            Debug.WriteLine($"LoadAndSortCards開始 - cards.Count: {cards.Count}");
            LoadLearningRecords();
            
            // 現在時刻
            var now = DateTime.Now;
            
            // カードを優先順位でソート
            sortedCards = cards.OrderBy(card =>
            {
                var record = learningRecords.ContainsKey(card.id) ? learningRecords[card.id] : null;
                
                // 1. 未学習のカードを最優先 (0)
                if (record == null || record.LastResult == null)
                {
                    Debug.WriteLine($"★未学習★カード優先: {card.id}");
                    return 0;
                }
                
                // 2. 復習時間が来ているカードを次に優先 (1)
                if (record.NextReviewDate <= now)
                {
                    Debug.WriteLine($"★復習時間★カード優先: {card.id}");
                    return 1;
                }
                
                // 3. 前回の回答が不正解のカードを優先 (2)
                if (record.LastResult == false)
                {
                    Debug.WriteLine($"★前回不正解★カード優先: {card.id}");
                    return 2;
                }
                
                // 4. その他は復習時間順 (3以降)
                return 3;
            })
            .ThenBy(card =>
            {
                var record = learningRecords.ContainsKey(card.id) ? learningRecords[card.id] : null;
                return record?.NextReviewDate ?? DateTime.MaxValue;
            })
            .ToList();
            
            // カードが空でないことを確認
            if (!sortedCards.Any())
            {
                sortedCards = cards.ToList();
            }
            
            Debug.WriteLine($"ソート後のカード順序: {sortedCards.Count}件");
            for (int i = 0; i < Math.Min(5, sortedCards.Count); i++)
            {
                var card = sortedCards[i];
                var record = learningRecords.ContainsKey(card.id) ? learningRecords[card.id] : null;
                var status = record?.LastResult == null ? "★未学習★" : 
                           record.NextReviewDate <= now ? "★復習時間★" :
                           record.LastResult == false ? "★前回不正解★" : "学習済み";
                Debug.WriteLine($"{i + 1}. {status} カードID: {card.id}");
            }
        }

        // 学習記録を読み込む
        private void LoadLearningRecords()
        {
            Debug.WriteLine("学習記録の読み込み開始");
            learningRecords.Clear();
            
            try
            {
                string resultFilePath = Path.Combine(tempExtractPath, "result.txt");
                
                if (!File.Exists(resultFilePath))
                {
                    Debug.WriteLine("result.txtが存在しません");
                    return;
                }
                
                var lines = File.ReadAllLines(resultFilePath);
                
                foreach (var line in lines)
                {
                    if (string.IsNullOrWhiteSpace(line)) continue;
                    
                    var parts = line.Split('|');
                    if (parts.Length >= 3)
                    {
                        var cardId = parts[0].Trim();
                        var isCorrect = parts[1].Trim() == "正解";
                        
                        if (DateTime.TryParse(parts[2].Trim(), out DateTime nextReviewDate))
                        {
                            // 既存の記録を取得または新規作成
                            if (!learningRecords.ContainsKey(cardId))
                            {
                                learningRecords[cardId] = new LearningRecord(cardId);
                            }
                            
                            var record = learningRecords[cardId];
                            
                            // 記録を更新
                            if (isCorrect)
                            {
                                record.CorrectCount++;
                            }
                            else
                            {
                                record.IncorrectCount++;
                            }
                            
                            record.LastResult = isCorrect;
                            record.NextReviewDate = nextReviewDate;
                        }
                    }
                }
                
                Debug.WriteLine($"読み込んだ学習記録数: {learningRecords.Count}");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"学習記録読み込み中にエラー: {ex.Message}");
            }
        }

        // 復習タイマーを開始
        private void StartReviewTimer()
        {
            StopReviewTimer();
            
            Debug.WriteLine("復習タイマーを開始");
            reviewTimer = new System.Timers.Timer(30000); // 30秒間隔
            reviewTimer.Elapsed += (sender, e) => CheckForReviewCards();
            reviewTimer.AutoReset = true;
            reviewTimer.Enabled = true;
        }

        // 復習タイマーを停止
        private void StopReviewTimer()
        {
            if (reviewTimer != null)
            {
                reviewTimer.Stop();
                reviewTimer.Dispose();
                reviewTimer = null;
                Debug.WriteLine("復習タイマーを停止");
            }
        }

        // 復習が必要なカードをチェック
        private void CheckForReviewCards()
        {
            MainThread.BeginInvokeOnMainThread(() =>
            {
                try
                {
                    var now = DateTime.Now;
                    
                    var needsReview = cards.Where(card =>
                    {
                        if (!learningRecords.ContainsKey(card.id)) return false;
                        
                        var record = learningRecords[card.id];
                        var isReviewTime = record.NextReviewDate <= now;
                        var isLastIncorrect = record.LastResult == false;
                        var isNotCurrentCard = currentIndex >= sortedCards.Count || card.id != sortedCards[currentIndex].id;
                        var isNotAlreadyInQueue = !sortedCards.Skip(currentIndex + 1).Any(c => c.id == card.id);
                        
                        return (isReviewTime || isLastIncorrect) && isNotCurrentCard && isNotAlreadyInQueue;
                    }).ToList();
                    
                    if (needsReview.Any())
                    {
                        Debug.WriteLine($"復習対象カード: {needsReview.Count}件");
                        foreach (var card in needsReview)
                        {
                            var record = learningRecords[card.id];
                            var reason = record.NextReviewDate <= now ? "復習時間到達" : "前回不正解";
                            Debug.WriteLine($"- カード{card.id}: {reason}");
                        }
                        PrioritizeReviewCards(needsReview);
                    }
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"復習チェック中にエラー: {ex.Message}");
                }
            });
        }

        // 復習カードを優先配置
        private void PrioritizeReviewCards(List<CardData> reviewCards)
        {
            var now = DateTime.Now;
            
            var sortedReviewCards = reviewCards.OrderBy(card =>
            {
                var record = learningRecords[card.id];
                
                // 復習時間が来ているカードを優先
                var isReviewTime = record.NextReviewDate <= now;
                var isLastIncorrect = record.LastResult == false;
                
                if (isReviewTime && !isLastIncorrect) return 0;
                if (isReviewTime && isLastIncorrect) return 1;
                if (!isReviewTime && isLastIncorrect) return 2;
                return 3;
            })
            .ThenBy(card => learningRecords[card.id].NextReviewDate)
            .ToList();
            
            var remainingCards = sortedCards.Skip(currentIndex + 1).ToList();
            var newSortedCards = sortedCards.Take(currentIndex + 1).ToList();
            newSortedCards.AddRange(sortedReviewCards);
            newSortedCards.AddRange(remainingCards.Where(c => !sortedReviewCards.Any(r => r.id == c.id)));
            
            sortedCards = newSortedCards;
            
            Debug.WriteLine("復習カードを次に配置完了");
            Debug.WriteLine($"新しい総カード数: {sortedCards.Count}");
        }

        // 復習が必要なカードを表示
        private void ShowReviewNeededCards()
        {
            var now = DateTime.Now;
            var reviewNeededCards = cards.Where(card =>
            {
                if (!learningRecords.ContainsKey(card.id)) return false;
                var record = learningRecords[card.id];
                return record.NextReviewDate <= now;
            }).ToList();
            
            if (reviewNeededCards.Any())
            {
                sortedCards = reviewNeededCards.OrderBy(card => learningRecords[card.id].NextReviewDate).ToList();
                currentIndex = 0;
                showAnswer = false;
                
                Debug.WriteLine($"復習カードで継続: {sortedCards.Count}件");
                DisplayCard();
            }
            else
            {
                Debug.WriteLine("すべての問題が完了しました");
                DisplayAlert("完了", "すべての問題が出題されました。", "OK");
                Navigation.PopAsync();
            }
        }

        // メモリ内の学習記録を更新
        private void UpdateLearningRecord(CardData card, bool isCorrect, DateTime nextReviewDate)
        {
            if (!learningRecords.ContainsKey(card.id))
            {
                learningRecords[card.id] = new LearningRecord(card.id);
            }
            
            var record = learningRecords[card.id];
            
            if (isCorrect)
            {
                record.CorrectCount++;
            }
            else
            {
                record.IncorrectCount++;
            }
            
            record.LastResult = isCorrect;
            record.NextReviewDate = nextReviewDate;
            
            Debug.WriteLine($"学習記録を更新: カード{card.id} - {(isCorrect ? "正解" : "不正解")} - 次回: {nextReviewDate}");
        }

        // Labelを使用した装飾文字表示の実装例
        public class RichTextLabel : Label
        {
            public static readonly BindableProperty RichTextProperty =
                BindableProperty.Create(nameof(RichText), typeof(string), typeof(RichTextLabel), string.Empty,
                    propertyChanged: OnRichTextChanged);

            public static readonly BindableProperty ShowAnswerProperty =
                BindableProperty.Create(nameof(ShowAnswer), typeof(bool), typeof(RichTextLabel), false,
                    propertyChanged: OnRichTextChanged);

            public static readonly BindableProperty ImageFolderPathProperty =
                BindableProperty.Create(nameof(ImageFolderPath), typeof(string), typeof(RichTextLabel), string.Empty);

            public string RichText
            {
                get => (string)GetValue(RichTextProperty);
                set => SetValue(RichTextProperty, value);
            }

            public bool ShowAnswer
            {
                get => (bool)GetValue(ShowAnswerProperty);
                set => SetValue(ShowAnswerProperty, value);
            }

            public string ImageFolderPath
            {
                get => (string)GetValue(ImageFolderPathProperty);
                set => SetValue(ImageFolderPathProperty, value);
            }

            private static void OnRichTextChanged(BindableObject bindable, object oldValue, object newValue)
            {
                if (bindable is RichTextLabel label)
                {
                    label.ProcessRichText();
                }
            }

            private void ProcessRichText()
            {
                var formattedString = ConvertToFormattedString(RichText);
                this.FormattedText = formattedString;
                
                // 高さを自動調整
                this.LineBreakMode = LineBreakMode.WordWrap;
                this.MaxLines = 0; // 無制限
            }

            private FormattedString ConvertToFormattedString(string text)
            {
                var formattedString = new FormattedString();
                
                if (string.IsNullOrWhiteSpace(text))
                {
                    return formattedString;
                }

                // 画像タグを処理
                text = ProcessImageTags(text);
                
                // 穴埋めを処理
                text = ProcessBlankTags(text);
                
                // 色付き文字を処理
                text = ProcessColorTags(text);
                
                // 太字を処理
                text = ProcessBoldTags(text, formattedString);
                
                // 上付き・下付きを処理
                text = ProcessSuperscriptSubscriptTags(text, formattedString);
                
                // 残りのテキストを追加
                if (!string.IsNullOrWhiteSpace(text))
                {
                    formattedString.Spans.Add(new Span { Text = text });
                }
                
                return formattedString;
            }

            private string ProcessImageTags(string text)
            {
                var matches = Regex.Matches(text, @"<<img_(.*?\.jpg)>>");
                foreach (Match match in matches)
                {
                    string imgFileName = match.Value.Trim('<', '>');
                    string imgPath = Path.Combine(ImageFolderPath, "img", imgFileName);
                    
                    if (File.Exists(imgPath))
                    {
                        // 画像が存在する場合は[画像]として表示
                        text = text.Replace(match.Value, "[画像]");
                    }
                    else
                    {
                        // 画像が存在しない場合はエラーメッセージ
                        text = text.Replace(match.Value, $"[画像が見つかりません: {imgFileName}]");
                    }
                }
                return text;
            }

            private string ProcessBlankTags(string text)
            {
                if (ShowAnswer)
                {
                    // 解答表示時は `<<blank|文字>>` → `(文字)`
                    text = Regex.Replace(text, @"<<blank\|(.*?)>>", match =>
                    {
                        var answer = match.Groups[1].Value;
                        return $"({answer})";
                    });
                }
                else
                {
                    // 問題表示時は `<<blank|文字>>` → `( )`
                    text = Regex.Replace(text, @"<<blank\|(.*?)>>", "( )");
                }
                return text;
            }

            private string ProcessColorTags(string text)
            {
                // 色付き文字の処理: {{red|文字}} → 赤色文字
                var colorPattern = @"\{\{(\w+)\|(.*?)\}\}";
                var matches = Regex.Matches(text, colorPattern);
                
                foreach (Match match in matches)
                {
                    var colorName = match.Groups[1].Value.ToLower();
                    var coloredText = match.Groups[2].Value;
                    
                    var color = GetColorFromName(colorName);
                    text = text.Replace(match.Value, $"<color:{colorName}>{coloredText}</color>");
                }
                
                return text;
            }

            private string ProcessBoldTags(string text, FormattedString formattedString)
            {
                // 太字の処理: **文字** → 太字
                var boldPattern = @"\*\*(.*?)\*\*";
                var matches = Regex.Matches(text, boldPattern);
                
                int lastIndex = 0;
                foreach (Match match in matches)
                {
                    // マッチ前のテキスト
                    if (match.Index > lastIndex)
                    {
                        var normalText = text.Substring(lastIndex, match.Index - lastIndex);
                        AddTextWithColors(normalText, formattedString);
                    }
                    
                    // 太字テキスト
                    var boldText = match.Groups[1].Value;
                    var boldSpan = new Span 
                    { 
                        Text = boldText,
                        FontAttributes = FontAttributes.Bold
                    };
                    formattedString.Spans.Add(boldSpan);
                    
                    lastIndex = match.Index + match.Length;
                }
                
                // 残りのテキスト
                if (lastIndex < text.Length)
                {
                    var remainingText = text.Substring(lastIndex);
                    AddTextWithColors(remainingText, formattedString);
                }
                
                return ""; // 太字処理後は空文字を返す（既にFormattedStringに追加済み）
            }

            private string ProcessSuperscriptSubscriptTags(string text, FormattedString formattedString)
            {
                // 上付きの処理: ^^文字^^ → 上付き
                var supPattern = @"\^\^(.*?)\^\^";
                var matches = Regex.Matches(text, supPattern);
                
                int lastIndex = 0;
                foreach (Match match in matches)
                {
                    // マッチ前のテキスト
                    if (match.Index > lastIndex)
                    {
                        var normalText = text.Substring(lastIndex, match.Index - lastIndex);
                        AddTextWithColors(normalText, formattedString);
                    }
                    
                    // 上付きテキスト
                    var supText = match.Groups[1].Value;
                    var supSpan = new Span 
                    { 
                        Text = supText,
                        FontSize = FontSize * 0.7 // フォントサイズを小さく
                    };
                    formattedString.Spans.Add(supSpan);
                    
                    lastIndex = match.Index + match.Length;
                }
                
                // 下付きの処理: ~~文字~~ → 下付き
                var subPattern = @"~~(.*?)~~";
                matches = Regex.Matches(text, subPattern);
                
                lastIndex = 0;
                foreach (Match match in matches)
                {
                    // マッチ前のテキスト
                    if (match.Index > lastIndex)
                    {
                        var normalText = text.Substring(lastIndex, match.Index - lastIndex);
                        AddTextWithColors(normalText, formattedString);
                    }
                    
                    // 下付きテキスト
                    var subText = match.Groups[1].Value;
                    var subSpan = new Span 
                    { 
                        Text = subText,
                        FontSize = FontSize * 0.7 // フォントサイズを小さく
                    };
                    formattedString.Spans.Add(subSpan);
                    
                    lastIndex = match.Index + match.Length;
                }
                
                // 残りのテキスト
                if (lastIndex < text.Length)
                {
                    var remainingText = text.Substring(lastIndex);
                    AddTextWithColors(remainingText, formattedString);
                }
                
                return ""; // 処理後は空文字を返す（既にFormattedStringに追加済み）
            }

            private void AddTextWithColors(string text, FormattedString formattedString)
            {
                // 色付きタグを処理
                var colorPattern = @"<color:(\w+)>(.*?)</color>";
                var matches = Regex.Matches(text, colorPattern);
                
                int lastIndex = 0;
                foreach (Match match in matches)
                {
                    // マッチ前のテキスト
                    if (match.Index > lastIndex)
                    {
                        var normalText = text.Substring(lastIndex, match.Index - lastIndex);
                        formattedString.Spans.Add(new Span { Text = normalText });
                    }
                    
                    // 色付きテキスト
                    var colorName = match.Groups[1].Value;
                    var coloredText = match.Groups[2].Value;
                    var color = GetColorFromName(colorName);
                    
                    var coloredSpan = new Span 
                    { 
                        Text = coloredText,
                        TextColor = color
                    };
                    formattedString.Spans.Add(coloredSpan);
                    
                    lastIndex = match.Index + match.Length;
                }
                
                // 残りのテキスト
                if (lastIndex < text.Length)
                {
                    var remainingText = text.Substring(lastIndex);
                    formattedString.Spans.Add(new Span { Text = remainingText });
                }
            }

            private Color GetColorFromName(string colorName)
            {
                return colorName.ToLower() switch
                {
                    "red" => Colors.Red,
                    "blue" => Colors.Blue,
                    "green" => Colors.Green,
                    "yellow" => Colors.Yellow,
                    "purple" => Colors.Purple,
                    "orange" => Colors.Orange,
                    "black" => Colors.Black,
                    "white" => Colors.White,
                    "gray" => Colors.Gray,
                    "brown" => Colors.Brown,
                    "pink" => Colors.Pink,
                    "cyan" => Colors.Cyan,
                    "magenta" => Colors.Magenta,
                    _ => Colors.Black // デフォルト
                };
            }
        }
    }
}

